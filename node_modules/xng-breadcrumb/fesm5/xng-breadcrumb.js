import { __decorate, __metadata, __assign, __spread, __read } from 'tslib';
import { Directive, ɵɵdefineInjectable, ɵɵinject, Injectable, TemplateRef, ContentChild, Input, Component, ViewEncapsulation, NgModule } from '@angular/core';
import { NavigationEnd, ActivatedRoute, Router, RouterModule } from '@angular/router';
import { BehaviorSubject } from 'rxjs';
import { filter, distinctUntilChanged } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

/**
 * This directive is used to customize the breadcrumb label behavior
 * *xngBreadcrumbItem directive can be used in the child element of xng-breadcrumb
 * Usage: refer to demo app.component.html
 */
var BreadcrumbItemDirective = /** @class */ (function () {
    function BreadcrumbItemDirective() {
    }
    BreadcrumbItemDirective = __decorate([
        Directive({
            selector: '[xngBreadcrumbItem]'
        }),
        __metadata("design:paramtypes", [])
    ], BreadcrumbItemDirective);
    return BreadcrumbItemDirective;
}());

var BreadcrumbService = /** @class */ (function () {
    function BreadcrumbService(activatedRoute, router) {
        this.activatedRoute = activatedRoute;
        this.router = router;
        this.baseHref = '/';
        /**
         * dynamicBreadcrumbStore holds information about dynamically updated breadcrumbs.
         * Breadcrumbs can be set from anywhere (component, service) in the app.
         * On every breadcrumb update check this store and use the info if available.
         */
        this.dynamicBreadcrumbStore = [];
        /**
         * breadcrumbList for the current route
         * When breadcrumb info is changed dynamically, check if the currentBreadcrumbs is effected
         * If effected, update the change and emit a new stream
         */
        this.currentBreadcrumbs = [];
        this.previousBreadcrumbs = [];
        /**
         * Breadcrumbs observable to be subscribed by BreadcrumbComponent
         * Emits on every route change OR dynamic update of breadcrumb
         */
        this.breadcrumbs = new BehaviorSubject([]);
        this.breadcrumbs$ = this.breadcrumbs.asObservable();
        this.pathParamPrefix = ':';
        this.pathParamRegexIdentifier = '/:[^/]+';
        this.pathParamRegexReplacer = '/[^/]+';
        this.setBaseBreadcrumb();
        this.detectRouteChanges();
    }
    /**
     * Update breadcrumb label or options for -
     *
     * route (complete route path). route can be passed the same way you define angular routes
     * 1) update label Ex: set('/mentor', 'Mentor'), set('/mentor/:id', 'Mentor Details')
     * 2) change visibility Ex: set('/mentor/:id/edit', { skip: true })
     * 3) add info Ex: set('/mentor/:id/edit', { info: { icon: 'edit', iconColor: 'blue' } })
     * ------------------------ OR -------------------------
     *
     * alias (prefixed with '@'). breadcrumb alias is unique for a route
     * 1) update label Ex: set('@mentor', 'Enabler')
     * 2) change visibility Ex: set('@mentorEdit', { skip: true })
     * 3) add info Ex: set('@mentorEdit', { info: { icon: 'edit', iconColor: 'blue' } })
     */
    BreadcrumbService.prototype.set = function (pathOrAlias, breadcrumb) {
        if (!this.validateArguments(pathOrAlias, breadcrumb)) {
            return;
        }
        if (typeof breadcrumb === 'string') {
            breadcrumb = {
                label: breadcrumb
            };
        }
        if (pathOrAlias.startsWith('@')) {
            this.updateStore(__assign(__assign({}, breadcrumb), { alias: pathOrAlias.slice(1) }));
        }
        else {
            var breadcrumbExtraProps = this.buildRouteRegExp(pathOrAlias);
            this.updateStore(__assign(__assign({}, breadcrumb), breadcrumbExtraProps));
        }
    };
    BreadcrumbService.prototype.setBaseBreadcrumb = function () {
        var baseConfig = this.router.config.find(function (pathConfig) { return pathConfig.path === ''; });
        if (baseConfig && baseConfig.data) {
            // tslint:disable-next-line: prefer-const
            var _a = this.getBreadcrumbOptions(baseConfig.data), label = _a.label, alias = _a.alias, _b = _a.skip, skip = _b === void 0 ? false : _b, info = _a.info, _c = _a.disable, disable = _c === void 0 ? false : _c;
            var isAutoGeneratedLabel = false;
            if (typeof label !== 'string' && !label) {
                label = '';
                isAutoGeneratedLabel = true;
            }
            this.baseBreadcrumb = {
                label: label,
                alias: alias,
                skip: skip,
                disable: disable,
                info: info,
                routeLink: this.baseHref,
                isAutoGeneratedLabel: isAutoGeneratedLabel
            };
        }
    };
    /**
     * Whenever route changes build breadcrumb list again
     */
    BreadcrumbService.prototype.detectRouteChanges = function () {
        var _this = this;
        this.router.events
            .pipe(filter(function (event) { return event instanceof NavigationEnd; }), distinctUntilChanged())
            .subscribe(function (event) {
            _this.previousBreadcrumbs = _this.currentBreadcrumbs;
            _this.currentBreadcrumbs = _this.baseBreadcrumb ? [_this.baseBreadcrumb] : [];
            _this.prepareBreadcrumbList(_this.activatedRoute.root, _this.baseHref);
        });
    };
    BreadcrumbService.prototype.prepareBreadcrumbList = function (activatedRoute, routeLinkPrefix) {
        if (activatedRoute.routeConfig && activatedRoute.routeConfig.path) {
            var breadcrumbItem = this.prepareBreadcrumbItem(activatedRoute, routeLinkPrefix);
            this.currentBreadcrumbs.push(breadcrumbItem);
            if (activatedRoute.firstChild) {
                return this.prepareBreadcrumbList(activatedRoute.firstChild, breadcrumbItem.routeLink + '/');
            }
        }
        else if (activatedRoute.firstChild) {
            return this.prepareBreadcrumbList(activatedRoute.firstChild, routeLinkPrefix);
        }
        var lastCrumb = this.currentBreadcrumbs[this.currentBreadcrumbs.length - 1];
        this.resolveQueryParamForLastItem(lastCrumb, activatedRoute);
        // remove breadcrumb items that needs to be hidden or don't have a label
        var breadcrumbsToShow = this.currentBreadcrumbs.filter(function (item) { return !item.skip; });
        this.breadcrumbs.next(breadcrumbsToShow);
    };
    BreadcrumbService.prototype.prepareBreadcrumbItem = function (activatedRoute, routeLinkPrefix) {
        var _a = this.parseRouteData(activatedRoute.routeConfig), path = _a.path, breadcrumb = _a.breadcrumb;
        // in case of path param get the resolved for param
        var resolvedPath = this.resolvePathParam(path, activatedRoute);
        var routeLink = "" + routeLinkPrefix + resolvedPath;
        // tslint:disable-next-line: prefer-const
        var _b = this.getFromStore(breadcrumb.alias, routeLink), label = _b.label, alias = _b.alias, skip = _b.skip, disable = _b.disable, info = _b.info;
        var isAutoGeneratedLabel = false;
        if (typeof label !== 'string') {
            if (typeof breadcrumb.label === 'string') {
                label = breadcrumb.label;
            }
            else {
                label = resolvedPath;
                isAutoGeneratedLabel = true;
            }
        }
        return __assign({ label: label, alias: alias || breadcrumb.alias, skip: skip || breadcrumb.skip, disable: disable || breadcrumb.disable, info: info || breadcrumb.info, routeLink: routeLink,
            isAutoGeneratedLabel: isAutoGeneratedLabel }, this.resolveQueryParam(routeLink));
    };
    /**
     * For a specific route, breadcrumb can be defined either on parent data OR it's child(which has empty path) data
     * When both are defined, child takes precedence
     *
     * Ex: Below we are setting breadcrumb on both parent and child.
     * So, child takes precedence and "Defined On Child" is displayed for the route 'home'
     * { path: 'home', loadChildren: './home/home.module#HomeModule' , data: {breadcrumb: "Defined On Module"}}
     *                                                AND
     * children: [
     *   { path: '', component: ShowUserComponent, data: {breadcrumb: "Defined On Child" }
     * ]
     */
    BreadcrumbService.prototype.parseRouteData = function (routeConfig) {
        var path = routeConfig.path, _a = routeConfig.data, data = _a === void 0 ? {} : _a;
        var breadcrumb = this.mergeWithBaseChildData(routeConfig, __assign({}, data));
        return { path: path, breadcrumb: breadcrumb };
    };
    BreadcrumbService.prototype.getFromStore = function (breadcrumbAlias, routeLink) {
        var matchingItem;
        if (breadcrumbAlias) {
            matchingItem = this.dynamicBreadcrumbStore.find(function (item) { return item.alias === breadcrumbAlias; });
        }
        if (!matchingItem && routeLink) {
            matchingItem = this.dynamicBreadcrumbStore.find(function (item) {
                return (item.routeLink && item.routeLink === routeLink) || (item.routeRegex && new RegExp(item.routeRegex).test(routeLink + '/'));
            });
        }
        return matchingItem || {};
    };
    /**
     * To update breadcrumb label for a route with path param, we need regex that matches route.
     * Instead of user providing regex, we help in preparing regex dynamically
     *
     * Ex: route declaration - path: '/mentor/:id'
     * breadcrumbService.set('/mentor/:id', 'Uday');
     * '/mentor/2' OR 'mentor/ada' we should use 'Uday' as label
     *
     * regex string is built, if route has path params(contains with ':')
     */
    BreadcrumbService.prototype.buildRouteRegExp = function (path) {
        // ensure leading slash is provided in the path
        if (!path.startsWith('/')) {
            path = '/' + path;
        }
        if (path.includes(this.pathParamPrefix)) {
            // replace mathing path param with a regex
            // '/mentor/:id' becomes '/mentor/[^/]', which further will be matched in updateStore
            var routeRegex = path.replace(new RegExp(this.pathParamRegexIdentifier, 'g'), this.pathParamRegexReplacer);
            return { routeRegex: routeRegex };
        }
        else {
            return { routeLink: path };
        }
    };
    /**
     * Update current breadcrumb definition and emit a new stream of breadcrumbs
     * Also update the store to reuse dynamic declarations
     */
    BreadcrumbService.prototype.updateStore = function (breadcrumb) {
        var _a = this.getBreadcrumbIndexes(breadcrumb), breadcrumbItemIndex = _a.breadcrumbItemIndex, storeItemIndex = _a.storeItemIndex;
        // if breadcrumb is present in current breadcrumbs update it and emit new stream
        if (breadcrumbItemIndex > -1) {
            this.currentBreadcrumbs[breadcrumbItemIndex] = __assign(__assign({}, this.currentBreadcrumbs[breadcrumbItemIndex]), breadcrumb);
            var breadcrumbsToShow = this.currentBreadcrumbs.filter(function (item) { return !item.skip; });
            this.breadcrumbs.next(__spread(breadcrumbsToShow));
        }
        // If the store already has this route definition update it, else add
        if (storeItemIndex > -1) {
            this.dynamicBreadcrumbStore[storeItemIndex] = __assign(__assign({}, this.dynamicBreadcrumbStore[storeItemIndex]), breadcrumb);
        }
        else {
            this.dynamicBreadcrumbStore.push(breadcrumb);
        }
    };
    BreadcrumbService.prototype.getBreadcrumbIndexes = function (breadcrumb) {
        var alias = breadcrumb.alias, routeLink = breadcrumb.routeLink, routeRegex = breadcrumb.routeRegex;
        var indexMap = {};
        // identify macthing breadcrumb and store item
        if (alias) {
            indexMap = this.getBreadcrumbIndexesByType('alias', alias);
        }
        else if (routeLink) {
            indexMap = this.getBreadcrumbIndexesByType('routeLink', routeLink);
        }
        else if (routeRegex) {
            indexMap = this.getBreadcrumbIndexesByType('routeRegex', routeRegex);
        }
        return indexMap;
    };
    BreadcrumbService.prototype.getBreadcrumbIndexesByType = function (key, value) {
        var breadcrumbItemIndex;
        if (key !== 'routeRegex') {
            breadcrumbItemIndex = this.currentBreadcrumbs.findIndex(function (item) { return value === item[key]; });
        }
        else {
            breadcrumbItemIndex = this.currentBreadcrumbs.findIndex(function (item) { return new RegExp(value).test(item.routeLink); });
        }
        var storeItemIndex = this.dynamicBreadcrumbStore.findIndex(function (item) { return value === item[key]; });
        return { breadcrumbItemIndex: breadcrumbItemIndex, storeItemIndex: storeItemIndex };
    };
    BreadcrumbService.prototype.resolvePathParam = function (path, activatedRoute) {
        // if the path segment is a route param, read the param value from url
        if (path.includes(this.pathParamPrefix)) {
            Object.entries(activatedRoute.snapshot.params).forEach(function (_a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                path = path.replace(":" + key, "" + value);
            });
        }
        return path;
    };
    BreadcrumbService.prototype.resolveQueryParam = function (routeLink) {
        var previousBreadcrumb = this.previousBreadcrumbs.find(function (item) { return item.routeLink === routeLink; }) || {};
        return {
            queryParams: previousBreadcrumb.queryParams,
            fragment: previousBreadcrumb.fragment
        };
    };
    BreadcrumbService.prototype.resolveQueryParamForLastItem = function (lastItem, activatedRoute) {
        var _a = activatedRoute.snapshot, queryParams = _a.queryParams, fragment = _a.fragment;
        // For last item in the crumbs set queryParams from activatedRoute
        if (lastItem) {
            lastItem.queryParams = Object.keys(queryParams).length > 0 ? __assign({}, queryParams) : undefined;
            lastItem.fragment = fragment;
        }
    };
    /**
     * get empty children of a module or Component. Empty child is the one with path: ''
     * When parent and it's children (that has empty route path) define data
     * merge them both with child taking precedence
     */
    BreadcrumbService.prototype.mergeWithBaseChildData = function (routeConfig, data) {
        if (!routeConfig) {
            return this.getBreadcrumbOptions(data);
        }
        var baseChild;
        if (routeConfig.loadChildren) {
            // To handle a module with empty child route
            baseChild = routeConfig._loadedConfig.routes.find(function (route) { return route.path === ''; });
        }
        else if (routeConfig.children) {
            // To handle a component with empty child route
            baseChild = routeConfig.children.find(function (route) { return route.path === ''; });
        }
        return baseChild && baseChild.data
            ? this.mergeWithBaseChildData(baseChild, __assign(__assign({}, this.getBreadcrumbOptions(data)), this.getBreadcrumbOptions(baseChild.data)))
            : this.getBreadcrumbOptions(data);
    };
    BreadcrumbService.prototype.validateArguments = function (pathOrAlias, breadcrumb) {
        if (pathOrAlias === null || pathOrAlias === undefined) {
            console.error('Invalid first argument. Please pass a route path or a breadcrumb alias.');
            return false;
        }
        else if (breadcrumb === null || breadcrumb === undefined) {
            console.error('Invalid second argument. Please pass a string or an Object with breadcrumb options.');
            return false;
        }
        return true;
    };
    /**
     * breadcrumb can be passed a label or an options object
     * If passed as a string convert to breadcrumb options object
     */
    BreadcrumbService.prototype.getBreadcrumbOptions = function (data) {
        var breadcrumb = data.breadcrumb;
        if (typeof breadcrumb === 'string' || !breadcrumb) {
            breadcrumb = {
                label: breadcrumb
            };
        }
        return breadcrumb;
    };
    BreadcrumbService.ctorParameters = function () { return [
        { type: ActivatedRoute },
        { type: Router }
    ]; };
    BreadcrumbService.ɵprov = ɵɵdefineInjectable({ factory: function BreadcrumbService_Factory() { return new BreadcrumbService(ɵɵinject(ActivatedRoute), ɵɵinject(Router)); }, token: BreadcrumbService, providedIn: "root" });
    BreadcrumbService = __decorate([
        Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [ActivatedRoute, Router])
    ], BreadcrumbService);
    return BreadcrumbService;
}());

var BreadcrumbComponent = /** @class */ (function () {
    function BreadcrumbComponent(breadcrumbService) {
        this.breadcrumbService = breadcrumbService;
        this._separator = '/';
        /**
         * If true, breadcrumb is auto generated even without any mapping label
         * Default label is same as route segment
         */
        this.autoGenerate = true;
        /**
         * By default query params will be preserved with breadcrumbs
         */
        this.preserveQueryParams = true;
        /**
         * custom class provided by consumer to increase specificity
         * This will benefit to override styles that are conflicting
         */
        this.class = '';
    }
    Object.defineProperty(BreadcrumbComponent.prototype, "separator", {
        get: function () {
            return this._separator;
        },
        /**
         * separator between breadcrumbs, defaults to '/'.
         * User can customize separator either by passing a String or Template
         *
         * String --> Ex: <xng-breadcrumb separator="-"> </xng-breadcrumb>
         *
         * Template --> Ex: <xng-breadcrumb [separator]="separatorTemplate"> </xng-breadcrumb>
         * <ng-template #separatorTemplate><mat-icon>arrow_right</mat-icon></ng-template>
         */
        set: function (value) {
            if (value instanceof TemplateRef) {
                this.separatorTemplate = value;
                this._separator = undefined;
            }
            else {
                this.separatorTemplate = undefined;
                this._separator = value || '/';
            }
        },
        enumerable: true,
        configurable: true
    });
    BreadcrumbComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscription = this.breadcrumbService.breadcrumbs$.subscribe(function (breadcrumbs) {
            _this.breadcrumbs = breadcrumbs
                .map(function (breadcrumb) {
                if (!_this.preserveQueryParams) {
                    breadcrumb.routeLink = breadcrumb.routeLink.split('?')[0];
                }
                return breadcrumb;
            })
                .filter(function (breadcrumb) {
                // Usually, breadcrumb list can contain a combination of auto generated and user specified labels
                // this filters autogenerated labels in case of "[autoGenerate]: false"
                if (_this.autoGenerate) {
                    return true;
                }
                return !breadcrumb.isAutoGeneratedLabel;
            });
        });
    };
    BreadcrumbComponent.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
    };
    BreadcrumbComponent.ctorParameters = function () { return [
        { type: BreadcrumbService }
    ]; };
    __decorate([
        ContentChild(BreadcrumbItemDirective, { static: false, read: TemplateRef }),
        __metadata("design:type", Object)
    ], BreadcrumbComponent.prototype, "itemTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BreadcrumbComponent.prototype, "autoGenerate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BreadcrumbComponent.prototype, "preserveQueryParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BreadcrumbComponent.prototype, "class", void 0);
    __decorate([
        Input('separator'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], BreadcrumbComponent.prototype, "separator", null);
    BreadcrumbComponent = __decorate([
        Component({
            selector: 'xng-breadcrumb',
            template: "<nav aria-label=\"breadcrumb\" class=\"xng-breadcrumb-root\" [ngClass]=\"class\">\n  <ol class=\"xng-breadcrumb-list\">\n    <ng-container *ngFor=\"let breadcrumb of breadcrumbs; last as isLast; first as isFirst\">\n      <li class=\"xng-breadcrumb-item\">\n        <a\n          *ngIf=\"!isLast\"\n          [routerLink]=\"[breadcrumb.routeLink]\"\n          class=\"xng-breadcrumb-link\"\n          [ngClass]=\"{ 'xng-breadcrumb-link-disabled': breadcrumb.disable }\"\n          [attr.aria-disabled]=\"breadcrumb.disable\"\n          [queryParams]=\"breadcrumb.queryParams\"\n          [fragment]=\"breadcrumb.fragment\"\n        >\n          <ng-container\n            *ngTemplateOutlet=\"itemTemplate; context: { $implicit: breadcrumb.label, info: breadcrumb.info, last: isLast, first: isFirst }\"\n          ></ng-container>\n          <ng-container *ngIf=\"!itemTemplate\">{{ breadcrumb.label }}</ng-container>\n        </a>\n\n        <label *ngIf=\"isLast\" class=\"xng-breadcrumb-trail\">\n          <ng-container\n            *ngTemplateOutlet=\"itemTemplate; context: { $implicit: breadcrumb.label, info: breadcrumb.info, last: isLast, first: isFirst }\"\n          ></ng-container>\n          <ng-container *ngIf=\"!itemTemplate\">{{ breadcrumb.label }}</ng-container>\n        </label>\n      </li>\n\n      <li *ngIf=\"!isLast\" class=\"xng-breadcrumb-separator\" aria-hidden=\"true\" role=\"separator\">\n        <ng-container *ngTemplateOutlet=\"separatorTemplate\"></ng-container>\n        <ng-container *ngIf=\"!separatorTemplate\">{{ separator }}</ng-container>\n      </li>\n    </ng-container>\n  </ol>\n</nav>\n",
            encapsulation: ViewEncapsulation.None,
            styles: [".xng-breadcrumb-root{margin:0;color:rgba(0,0,0,.6)}.xng-breadcrumb-list{display:flex;align-items:center;flex-wrap:wrap;margin:0;padding:0}.xng-breadcrumb-item{list-style:none}.xng-breadcrumb-trail{display:flex;align-items:center;color:rgba(0,0,0,.9)}.xng-breadcrumb-link{display:flex;align-items:center;white-space:nowrap;color:inherit;text-decoration:none;transition:text-decoration .3s;transition:text-decoration .3s,-webkit-text-decoration .3s}.xng-breadcrumb-link:hover{text-decoration:underline}.xng-breadcrumb-link-disabled{pointer-events:none;cursor:disabled}.xng-breadcrumb-separator{display:flex;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-left:8px;margin-right:8px}"]
        }),
        __metadata("design:paramtypes", [BreadcrumbService])
    ], BreadcrumbComponent);
    return BreadcrumbComponent;
}());

var BreadcrumbModule = /** @class */ (function () {
    function BreadcrumbModule() {
    }
    BreadcrumbModule = __decorate([
        NgModule({
            declarations: [BreadcrumbComponent, BreadcrumbItemDirective],
            imports: [CommonModule, RouterModule],
            exports: [BreadcrumbComponent, BreadcrumbItemDirective]
        })
    ], BreadcrumbModule);
    return BreadcrumbModule;
}());

/*
 * Public API Surface of xng-breadcrumb
 */

/**
 * Generated bundle index. Do not edit.
 */

export { BreadcrumbComponent, BreadcrumbItemDirective, BreadcrumbModule, BreadcrumbService };
//# sourceMappingURL=xng-breadcrumb.js.map
