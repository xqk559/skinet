(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/router'), require('rxjs'), require('rxjs/operators'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('xng-breadcrumb', ['exports', '@angular/core', '@angular/router', 'rxjs', 'rxjs/operators', '@angular/common'], factory) :
    (global = global || self, factory(global['xng-breadcrumb'] = {}, global.ng.core, global.ng.router, global.rxjs, global.rxjs.operators, global.ng.common));
}(this, (function (exports, core, router, rxjs, operators, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * This directive is used to customize the breadcrumb label behavior
     * *xngBreadcrumbItem directive can be used in the child element of xng-breadcrumb
     * Usage: refer to demo app.component.html
     */
    var BreadcrumbItemDirective = /** @class */ (function () {
        function BreadcrumbItemDirective() {
        }
        BreadcrumbItemDirective = __decorate([
            core.Directive({
                selector: '[xngBreadcrumbItem]'
            }),
            __metadata("design:paramtypes", [])
        ], BreadcrumbItemDirective);
        return BreadcrumbItemDirective;
    }());

    var BreadcrumbService = /** @class */ (function () {
        function BreadcrumbService(activatedRoute, router) {
            this.activatedRoute = activatedRoute;
            this.router = router;
            this.baseHref = '/';
            /**
             * dynamicBreadcrumbStore holds information about dynamically updated breadcrumbs.
             * Breadcrumbs can be set from anywhere (component, service) in the app.
             * On every breadcrumb update check this store and use the info if available.
             */
            this.dynamicBreadcrumbStore = [];
            /**
             * breadcrumbList for the current route
             * When breadcrumb info is changed dynamically, check if the currentBreadcrumbs is effected
             * If effected, update the change and emit a new stream
             */
            this.currentBreadcrumbs = [];
            this.previousBreadcrumbs = [];
            /**
             * Breadcrumbs observable to be subscribed by BreadcrumbComponent
             * Emits on every route change OR dynamic update of breadcrumb
             */
            this.breadcrumbs = new rxjs.BehaviorSubject([]);
            this.breadcrumbs$ = this.breadcrumbs.asObservable();
            this.pathParamPrefix = ':';
            this.pathParamRegexIdentifier = '/:[^/]+';
            this.pathParamRegexReplacer = '/[^/]+';
            this.setBaseBreadcrumb();
            this.detectRouteChanges();
        }
        /**
         * Update breadcrumb label or options for -
         *
         * route (complete route path). route can be passed the same way you define angular routes
         * 1) update label Ex: set('/mentor', 'Mentor'), set('/mentor/:id', 'Mentor Details')
         * 2) change visibility Ex: set('/mentor/:id/edit', { skip: true })
         * 3) add info Ex: set('/mentor/:id/edit', { info: { icon: 'edit', iconColor: 'blue' } })
         * ------------------------ OR -------------------------
         *
         * alias (prefixed with '@'). breadcrumb alias is unique for a route
         * 1) update label Ex: set('@mentor', 'Enabler')
         * 2) change visibility Ex: set('@mentorEdit', { skip: true })
         * 3) add info Ex: set('@mentorEdit', { info: { icon: 'edit', iconColor: 'blue' } })
         */
        BreadcrumbService.prototype.set = function (pathOrAlias, breadcrumb) {
            if (!this.validateArguments(pathOrAlias, breadcrumb)) {
                return;
            }
            if (typeof breadcrumb === 'string') {
                breadcrumb = {
                    label: breadcrumb
                };
            }
            if (pathOrAlias.startsWith('@')) {
                this.updateStore(__assign(__assign({}, breadcrumb), { alias: pathOrAlias.slice(1) }));
            }
            else {
                var breadcrumbExtraProps = this.buildRouteRegExp(pathOrAlias);
                this.updateStore(__assign(__assign({}, breadcrumb), breadcrumbExtraProps));
            }
        };
        BreadcrumbService.prototype.setBaseBreadcrumb = function () {
            var baseConfig = this.router.config.find(function (pathConfig) { return pathConfig.path === ''; });
            if (baseConfig && baseConfig.data) {
                // tslint:disable-next-line: prefer-const
                var _a = this.getBreadcrumbOptions(baseConfig.data), label = _a.label, alias = _a.alias, _b = _a.skip, skip = _b === void 0 ? false : _b, info = _a.info, _c = _a.disable, disable = _c === void 0 ? false : _c;
                var isAutoGeneratedLabel = false;
                if (typeof label !== 'string' && !label) {
                    label = '';
                    isAutoGeneratedLabel = true;
                }
                this.baseBreadcrumb = {
                    label: label,
                    alias: alias,
                    skip: skip,
                    disable: disable,
                    info: info,
                    routeLink: this.baseHref,
                    isAutoGeneratedLabel: isAutoGeneratedLabel
                };
            }
        };
        /**
         * Whenever route changes build breadcrumb list again
         */
        BreadcrumbService.prototype.detectRouteChanges = function () {
            var _this = this;
            this.router.events
                .pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd; }), operators.distinctUntilChanged())
                .subscribe(function (event) {
                _this.previousBreadcrumbs = _this.currentBreadcrumbs;
                _this.currentBreadcrumbs = _this.baseBreadcrumb ? [_this.baseBreadcrumb] : [];
                _this.prepareBreadcrumbList(_this.activatedRoute.root, _this.baseHref);
            });
        };
        BreadcrumbService.prototype.prepareBreadcrumbList = function (activatedRoute, routeLinkPrefix) {
            if (activatedRoute.routeConfig && activatedRoute.routeConfig.path) {
                var breadcrumbItem = this.prepareBreadcrumbItem(activatedRoute, routeLinkPrefix);
                this.currentBreadcrumbs.push(breadcrumbItem);
                if (activatedRoute.firstChild) {
                    return this.prepareBreadcrumbList(activatedRoute.firstChild, breadcrumbItem.routeLink + '/');
                }
            }
            else if (activatedRoute.firstChild) {
                return this.prepareBreadcrumbList(activatedRoute.firstChild, routeLinkPrefix);
            }
            var lastCrumb = this.currentBreadcrumbs[this.currentBreadcrumbs.length - 1];
            this.resolveQueryParamForLastItem(lastCrumb, activatedRoute);
            // remove breadcrumb items that needs to be hidden or don't have a label
            var breadcrumbsToShow = this.currentBreadcrumbs.filter(function (item) { return !item.skip; });
            this.breadcrumbs.next(breadcrumbsToShow);
        };
        BreadcrumbService.prototype.prepareBreadcrumbItem = function (activatedRoute, routeLinkPrefix) {
            var _a = this.parseRouteData(activatedRoute.routeConfig), path = _a.path, breadcrumb = _a.breadcrumb;
            // in case of path param get the resolved for param
            var resolvedPath = this.resolvePathParam(path, activatedRoute);
            var routeLink = "" + routeLinkPrefix + resolvedPath;
            // tslint:disable-next-line: prefer-const
            var _b = this.getFromStore(breadcrumb.alias, routeLink), label = _b.label, alias = _b.alias, skip = _b.skip, disable = _b.disable, info = _b.info;
            var isAutoGeneratedLabel = false;
            if (typeof label !== 'string') {
                if (typeof breadcrumb.label === 'string') {
                    label = breadcrumb.label;
                }
                else {
                    label = resolvedPath;
                    isAutoGeneratedLabel = true;
                }
            }
            return __assign({ label: label, alias: alias || breadcrumb.alias, skip: skip || breadcrumb.skip, disable: disable || breadcrumb.disable, info: info || breadcrumb.info, routeLink: routeLink,
                isAutoGeneratedLabel: isAutoGeneratedLabel }, this.resolveQueryParam(routeLink));
        };
        /**
         * For a specific route, breadcrumb can be defined either on parent data OR it's child(which has empty path) data
         * When both are defined, child takes precedence
         *
         * Ex: Below we are setting breadcrumb on both parent and child.
         * So, child takes precedence and "Defined On Child" is displayed for the route 'home'
         * { path: 'home', loadChildren: './home/home.module#HomeModule' , data: {breadcrumb: "Defined On Module"}}
         *                                                AND
         * children: [
         *   { path: '', component: ShowUserComponent, data: {breadcrumb: "Defined On Child" }
         * ]
         */
        BreadcrumbService.prototype.parseRouteData = function (routeConfig) {
            var path = routeConfig.path, _a = routeConfig.data, data = _a === void 0 ? {} : _a;
            var breadcrumb = this.mergeWithBaseChildData(routeConfig, __assign({}, data));
            return { path: path, breadcrumb: breadcrumb };
        };
        BreadcrumbService.prototype.getFromStore = function (breadcrumbAlias, routeLink) {
            var matchingItem;
            if (breadcrumbAlias) {
                matchingItem = this.dynamicBreadcrumbStore.find(function (item) { return item.alias === breadcrumbAlias; });
            }
            if (!matchingItem && routeLink) {
                matchingItem = this.dynamicBreadcrumbStore.find(function (item) {
                    return (item.routeLink && item.routeLink === routeLink) || (item.routeRegex && new RegExp(item.routeRegex).test(routeLink + '/'));
                });
            }
            return matchingItem || {};
        };
        /**
         * To update breadcrumb label for a route with path param, we need regex that matches route.
         * Instead of user providing regex, we help in preparing regex dynamically
         *
         * Ex: route declaration - path: '/mentor/:id'
         * breadcrumbService.set('/mentor/:id', 'Uday');
         * '/mentor/2' OR 'mentor/ada' we should use 'Uday' as label
         *
         * regex string is built, if route has path params(contains with ':')
         */
        BreadcrumbService.prototype.buildRouteRegExp = function (path) {
            // ensure leading slash is provided in the path
            if (!path.startsWith('/')) {
                path = '/' + path;
            }
            if (path.includes(this.pathParamPrefix)) {
                // replace mathing path param with a regex
                // '/mentor/:id' becomes '/mentor/[^/]', which further will be matched in updateStore
                var routeRegex = path.replace(new RegExp(this.pathParamRegexIdentifier, 'g'), this.pathParamRegexReplacer);
                return { routeRegex: routeRegex };
            }
            else {
                return { routeLink: path };
            }
        };
        /**
         * Update current breadcrumb definition and emit a new stream of breadcrumbs
         * Also update the store to reuse dynamic declarations
         */
        BreadcrumbService.prototype.updateStore = function (breadcrumb) {
            var _a = this.getBreadcrumbIndexes(breadcrumb), breadcrumbItemIndex = _a.breadcrumbItemIndex, storeItemIndex = _a.storeItemIndex;
            // if breadcrumb is present in current breadcrumbs update it and emit new stream
            if (breadcrumbItemIndex > -1) {
                this.currentBreadcrumbs[breadcrumbItemIndex] = __assign(__assign({}, this.currentBreadcrumbs[breadcrumbItemIndex]), breadcrumb);
                var breadcrumbsToShow = this.currentBreadcrumbs.filter(function (item) { return !item.skip; });
                this.breadcrumbs.next(__spread(breadcrumbsToShow));
            }
            // If the store already has this route definition update it, else add
            if (storeItemIndex > -1) {
                this.dynamicBreadcrumbStore[storeItemIndex] = __assign(__assign({}, this.dynamicBreadcrumbStore[storeItemIndex]), breadcrumb);
            }
            else {
                this.dynamicBreadcrumbStore.push(breadcrumb);
            }
        };
        BreadcrumbService.prototype.getBreadcrumbIndexes = function (breadcrumb) {
            var alias = breadcrumb.alias, routeLink = breadcrumb.routeLink, routeRegex = breadcrumb.routeRegex;
            var indexMap = {};
            // identify macthing breadcrumb and store item
            if (alias) {
                indexMap = this.getBreadcrumbIndexesByType('alias', alias);
            }
            else if (routeLink) {
                indexMap = this.getBreadcrumbIndexesByType('routeLink', routeLink);
            }
            else if (routeRegex) {
                indexMap = this.getBreadcrumbIndexesByType('routeRegex', routeRegex);
            }
            return indexMap;
        };
        BreadcrumbService.prototype.getBreadcrumbIndexesByType = function (key, value) {
            var breadcrumbItemIndex;
            if (key !== 'routeRegex') {
                breadcrumbItemIndex = this.currentBreadcrumbs.findIndex(function (item) { return value === item[key]; });
            }
            else {
                breadcrumbItemIndex = this.currentBreadcrumbs.findIndex(function (item) { return new RegExp(value).test(item.routeLink); });
            }
            var storeItemIndex = this.dynamicBreadcrumbStore.findIndex(function (item) { return value === item[key]; });
            return { breadcrumbItemIndex: breadcrumbItemIndex, storeItemIndex: storeItemIndex };
        };
        BreadcrumbService.prototype.resolvePathParam = function (path, activatedRoute) {
            // if the path segment is a route param, read the param value from url
            if (path.includes(this.pathParamPrefix)) {
                Object.entries(activatedRoute.snapshot.params).forEach(function (_a) {
                    var _b = __read(_a, 2), key = _b[0], value = _b[1];
                    path = path.replace(":" + key, "" + value);
                });
            }
            return path;
        };
        BreadcrumbService.prototype.resolveQueryParam = function (routeLink) {
            var previousBreadcrumb = this.previousBreadcrumbs.find(function (item) { return item.routeLink === routeLink; }) || {};
            return {
                queryParams: previousBreadcrumb.queryParams,
                fragment: previousBreadcrumb.fragment
            };
        };
        BreadcrumbService.prototype.resolveQueryParamForLastItem = function (lastItem, activatedRoute) {
            var _a = activatedRoute.snapshot, queryParams = _a.queryParams, fragment = _a.fragment;
            // For last item in the crumbs set queryParams from activatedRoute
            if (lastItem) {
                lastItem.queryParams = Object.keys(queryParams).length > 0 ? __assign({}, queryParams) : undefined;
                lastItem.fragment = fragment;
            }
        };
        /**
         * get empty children of a module or Component. Empty child is the one with path: ''
         * When parent and it's children (that has empty route path) define data
         * merge them both with child taking precedence
         */
        BreadcrumbService.prototype.mergeWithBaseChildData = function (routeConfig, data) {
            if (!routeConfig) {
                return this.getBreadcrumbOptions(data);
            }
            var baseChild;
            if (routeConfig.loadChildren) {
                // To handle a module with empty child route
                baseChild = routeConfig._loadedConfig.routes.find(function (route) { return route.path === ''; });
            }
            else if (routeConfig.children) {
                // To handle a component with empty child route
                baseChild = routeConfig.children.find(function (route) { return route.path === ''; });
            }
            return baseChild && baseChild.data
                ? this.mergeWithBaseChildData(baseChild, __assign(__assign({}, this.getBreadcrumbOptions(data)), this.getBreadcrumbOptions(baseChild.data)))
                : this.getBreadcrumbOptions(data);
        };
        BreadcrumbService.prototype.validateArguments = function (pathOrAlias, breadcrumb) {
            if (pathOrAlias === null || pathOrAlias === undefined) {
                console.error('Invalid first argument. Please pass a route path or a breadcrumb alias.');
                return false;
            }
            else if (breadcrumb === null || breadcrumb === undefined) {
                console.error('Invalid second argument. Please pass a string or an Object with breadcrumb options.');
                return false;
            }
            return true;
        };
        /**
         * breadcrumb can be passed a label or an options object
         * If passed as a string convert to breadcrumb options object
         */
        BreadcrumbService.prototype.getBreadcrumbOptions = function (data) {
            var breadcrumb = data.breadcrumb;
            if (typeof breadcrumb === 'string' || !breadcrumb) {
                breadcrumb = {
                    label: breadcrumb
                };
            }
            return breadcrumb;
        };
        BreadcrumbService.ctorParameters = function () { return [
            { type: router.ActivatedRoute },
            { type: router.Router }
        ]; };
        BreadcrumbService.ɵprov = core.ɵɵdefineInjectable({ factory: function BreadcrumbService_Factory() { return new BreadcrumbService(core.ɵɵinject(router.ActivatedRoute), core.ɵɵinject(router.Router)); }, token: BreadcrumbService, providedIn: "root" });
        BreadcrumbService = __decorate([
            core.Injectable({
                providedIn: 'root'
            }),
            __metadata("design:paramtypes", [router.ActivatedRoute, router.Router])
        ], BreadcrumbService);
        return BreadcrumbService;
    }());

    var BreadcrumbComponent = /** @class */ (function () {
        function BreadcrumbComponent(breadcrumbService) {
            this.breadcrumbService = breadcrumbService;
            this._separator = '/';
            /**
             * If true, breadcrumb is auto generated even without any mapping label
             * Default label is same as route segment
             */
            this.autoGenerate = true;
            /**
             * By default query params will be preserved with breadcrumbs
             */
            this.preserveQueryParams = true;
            /**
             * custom class provided by consumer to increase specificity
             * This will benefit to override styles that are conflicting
             */
            this.class = '';
        }
        Object.defineProperty(BreadcrumbComponent.prototype, "separator", {
            get: function () {
                return this._separator;
            },
            /**
             * separator between breadcrumbs, defaults to '/'.
             * User can customize separator either by passing a String or Template
             *
             * String --> Ex: <xng-breadcrumb separator="-"> </xng-breadcrumb>
             *
             * Template --> Ex: <xng-breadcrumb [separator]="separatorTemplate"> </xng-breadcrumb>
             * <ng-template #separatorTemplate><mat-icon>arrow_right</mat-icon></ng-template>
             */
            set: function (value) {
                if (value instanceof core.TemplateRef) {
                    this.separatorTemplate = value;
                    this._separator = undefined;
                }
                else {
                    this.separatorTemplate = undefined;
                    this._separator = value || '/';
                }
            },
            enumerable: true,
            configurable: true
        });
        BreadcrumbComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription = this.breadcrumbService.breadcrumbs$.subscribe(function (breadcrumbs) {
                _this.breadcrumbs = breadcrumbs
                    .map(function (breadcrumb) {
                    if (!_this.preserveQueryParams) {
                        breadcrumb.routeLink = breadcrumb.routeLink.split('?')[0];
                    }
                    return breadcrumb;
                })
                    .filter(function (breadcrumb) {
                    // Usually, breadcrumb list can contain a combination of auto generated and user specified labels
                    // this filters autogenerated labels in case of "[autoGenerate]: false"
                    if (_this.autoGenerate) {
                        return true;
                    }
                    return !breadcrumb.isAutoGeneratedLabel;
                });
            });
        };
        BreadcrumbComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        BreadcrumbComponent.ctorParameters = function () { return [
            { type: BreadcrumbService }
        ]; };
        __decorate([
            core.ContentChild(BreadcrumbItemDirective, { static: false, read: core.TemplateRef }),
            __metadata("design:type", Object)
        ], BreadcrumbComponent.prototype, "itemTemplate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], BreadcrumbComponent.prototype, "autoGenerate", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], BreadcrumbComponent.prototype, "preserveQueryParams", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], BreadcrumbComponent.prototype, "class", void 0);
        __decorate([
            core.Input('separator'),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], BreadcrumbComponent.prototype, "separator", null);
        BreadcrumbComponent = __decorate([
            core.Component({
                selector: 'xng-breadcrumb',
                template: "<nav aria-label=\"breadcrumb\" class=\"xng-breadcrumb-root\" [ngClass]=\"class\">\n  <ol class=\"xng-breadcrumb-list\">\n    <ng-container *ngFor=\"let breadcrumb of breadcrumbs; last as isLast; first as isFirst\">\n      <li class=\"xng-breadcrumb-item\">\n        <a\n          *ngIf=\"!isLast\"\n          [routerLink]=\"[breadcrumb.routeLink]\"\n          class=\"xng-breadcrumb-link\"\n          [ngClass]=\"{ 'xng-breadcrumb-link-disabled': breadcrumb.disable }\"\n          [attr.aria-disabled]=\"breadcrumb.disable\"\n          [queryParams]=\"breadcrumb.queryParams\"\n          [fragment]=\"breadcrumb.fragment\"\n        >\n          <ng-container\n            *ngTemplateOutlet=\"itemTemplate; context: { $implicit: breadcrumb.label, info: breadcrumb.info, last: isLast, first: isFirst }\"\n          ></ng-container>\n          <ng-container *ngIf=\"!itemTemplate\">{{ breadcrumb.label }}</ng-container>\n        </a>\n\n        <label *ngIf=\"isLast\" class=\"xng-breadcrumb-trail\">\n          <ng-container\n            *ngTemplateOutlet=\"itemTemplate; context: { $implicit: breadcrumb.label, info: breadcrumb.info, last: isLast, first: isFirst }\"\n          ></ng-container>\n          <ng-container *ngIf=\"!itemTemplate\">{{ breadcrumb.label }}</ng-container>\n        </label>\n      </li>\n\n      <li *ngIf=\"!isLast\" class=\"xng-breadcrumb-separator\" aria-hidden=\"true\" role=\"separator\">\n        <ng-container *ngTemplateOutlet=\"separatorTemplate\"></ng-container>\n        <ng-container *ngIf=\"!separatorTemplate\">{{ separator }}</ng-container>\n      </li>\n    </ng-container>\n  </ol>\n</nav>\n",
                encapsulation: core.ViewEncapsulation.None,
                styles: [".xng-breadcrumb-root{margin:0;color:rgba(0,0,0,.6)}.xng-breadcrumb-list{display:flex;align-items:center;flex-wrap:wrap;margin:0;padding:0}.xng-breadcrumb-item{list-style:none}.xng-breadcrumb-trail{display:flex;align-items:center;color:rgba(0,0,0,.9)}.xng-breadcrumb-link{display:flex;align-items:center;white-space:nowrap;color:inherit;text-decoration:none;transition:text-decoration .3s;transition:text-decoration .3s,-webkit-text-decoration .3s}.xng-breadcrumb-link:hover{text-decoration:underline}.xng-breadcrumb-link-disabled{pointer-events:none;cursor:disabled}.xng-breadcrumb-separator{display:flex;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-left:8px;margin-right:8px}"]
            }),
            __metadata("design:paramtypes", [BreadcrumbService])
        ], BreadcrumbComponent);
        return BreadcrumbComponent;
    }());

    var BreadcrumbModule = /** @class */ (function () {
        function BreadcrumbModule() {
        }
        BreadcrumbModule = __decorate([
            core.NgModule({
                declarations: [BreadcrumbComponent, BreadcrumbItemDirective],
                imports: [common.CommonModule, router.RouterModule],
                exports: [BreadcrumbComponent, BreadcrumbItemDirective]
            })
        ], BreadcrumbModule);
        return BreadcrumbModule;
    }());

    exports.BreadcrumbComponent = BreadcrumbComponent;
    exports.BreadcrumbItemDirective = BreadcrumbItemDirective;
    exports.BreadcrumbModule = BreadcrumbModule;
    exports.BreadcrumbService = BreadcrumbService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=xng-breadcrumb.umd.js.map
